From b021ad7034b27174b24f11ccdb774ca7384dbdbc Mon Sep 17 00:00:00 2001
From: Tim Lunn <tim@feathertop.org>
Date: Tue, 12 Sep 2023 01:10:21 +1000
Subject: [PATCH] ram: rockchip: Add rv1126 ddr4 support

---
 arch/arm/include/asm/arch-rockchip/rk_atags.h | 321 +++++++++++++++
 arch/arm/mach-rockchip/Kconfig                |   8 +
 arch/arm/mach-rockchip/Makefile               |   1 +
 arch/arm/mach-rockchip/rk_atags.c             | 388 ++++++++++++++++++
 arch/arm/mach-rockchip/sdram.c                |   1 +
 .../sdram-rv1126-ddr4-detect-1056.inc         |  75 ++++
 .../rockchip/sdram-rv1126-ddr4-detect-328.inc |  75 ++++
 .../rockchip/sdram-rv1126-ddr4-detect-396.inc |  75 ++++
 .../rockchip/sdram-rv1126-ddr4-detect-528.inc |  75 ++++
 .../rockchip/sdram-rv1126-ddr4-detect-664.inc |  75 ++++
 .../rockchip/sdram-rv1126-ddr4-detect-784.inc |  75 ++++
 .../rockchip/sdram-rv1126-ddr4-detect-924.inc |  75 ++++
 drivers/ram/rockchip/sdram_rv1126.c           |  72 ++++
 13 files changed, 1316 insertions(+)
 create mode 100644 arch/arm/include/asm/arch-rockchip/rk_atags.h
 create mode 100644 arch/arm/mach-rockchip/rk_atags.c
 create mode 100644 drivers/ram/rockchip/sdram-rv1126-ddr4-detect-1056.inc
 create mode 100644 drivers/ram/rockchip/sdram-rv1126-ddr4-detect-328.inc
 create mode 100644 drivers/ram/rockchip/sdram-rv1126-ddr4-detect-396.inc
 create mode 100644 drivers/ram/rockchip/sdram-rv1126-ddr4-detect-528.inc
 create mode 100644 drivers/ram/rockchip/sdram-rv1126-ddr4-detect-664.inc
 create mode 100644 drivers/ram/rockchip/sdram-rv1126-ddr4-detect-784.inc
 create mode 100644 drivers/ram/rockchip/sdram-rv1126-ddr4-detect-924.inc

diff --git a/arch/arm/include/asm/arch-rockchip/rk_atags.h b/arch/arm/include/asm/arch-rockchip/rk_atags.h
new file mode 100644
index 0000000000..d48cf92ab3
--- /dev/null
+++ b/arch/arm/include/asm/arch-rockchip/rk_atags.h
@@ -0,0 +1,321 @@
+/* SPDX-License-Identifier:     GPL-2.0+ */
+/*
+ * (C) Copyright 2018 Rockchip Electronics Co., Ltd
+ *
+ */
+
+#ifndef __RK_ATAGS_H_
+#define __RK_ATAGS_H_
+
+/* Tag magic */
+#define ATAG_CORE		0x54410001
+#define ATAG_NONE		0x00000000
+
+#define ATAG_SERIAL		0x54410050
+#define ATAG_BOOTDEV		0x54410051
+#define ATAG_DDR_MEM		0x54410052
+#define ATAG_TOS_MEM		0x54410053
+#define ATAG_RAM_PARTITION	0x54410054
+#define ATAG_ATF_MEM		0x54410055
+#define ATAG_PUB_KEY		0x54410056
+#define ATAG_SOC_INFO		0x54410057
+#define ATAG_BOOT1_PARAM	0x54410058
+#define ATAG_MAX		0x544100ff
+
+/* Tag size and offset */
+#define ATAGS_SIZE		(0x2000)	/* 8K */
+#define ATAGS_OFFSET		(0x200000 - ATAGS_SIZE)/* [2M-8K, 2M] */
+
+/* Tag sdram position!! */
+#define ATAGS_PHYS_BASE		(CFG_SYS_SDRAM_BASE + ATAGS_OFFSET)
+
+#ifndef ATAGS_PHYS_BASE
+"ERROR: ATAGS_PHYS_BASE is not defined!!"
+#endif
+
+/* tag_bootdev.devtype */
+#define BOOT_TYPE_UNKNOWN	0
+#define BOOT_TYPE_NAND		(1 << 0)
+#define BOOT_TYPE_EMMC		(1 << 1)
+#define BOOT_TYPE_SD0		(1 << 2)
+#define BOOT_TYPE_SD1		(1 << 3)
+#define BOOT_TYPE_SPI_NOR	(1 << 4)
+#define BOOT_TYPE_SPI_NAND	(1 << 5)
+#define BOOT_TYPE_RAM		(1 << 6)
+#define BOOT_TYPE_MTD_BLK_NAND	(1 << 7)
+#define BOOT_TYPE_MTD_BLK_SPI_NAND	(1 << 8)
+#define BOOT_TYPE_MTD_BLK_SPI_NOR	(1 << 9)
+#define BOOT_TYPE_SATA		(1 << 10)
+#define BOOT_TYPE_PCIE		(1 << 11)
+
+/* define sd card function */
+#define SD_UNKNOWN_CARD		0
+#define SD_UPDATE_CARD		1
+
+/* tag_serial.m_mode */
+#define SERIAL_M_MODE_M0	0x0
+#define SERIAL_M_MODE_M1	0x1
+#define SERIAL_M_MODE_M2	0x2
+
+/* tag_soc_info.flags */
+#define SOC_FLAGS_ET00		0x45543030
+#define SOC_FLAGS_ET01		0x45543031
+#define SOC_FLAGS_ET02		0x45543032
+
+/* pub key programmed magic */
+#define PUBKEY_FUSE_PROGRAMMED	0x4B415352
+
+/*
+ * boot1p.param[2] for ATF/OPTEE. The fields:
+ *
+ * [31:12]: reserved
+ * [4:0]: boot cpu hwid.
+ */
+#define B1P2_BOOT_CPU_MASK	0x00000fff
+
+/* tag_ddr_mem.flags */
+#define DDR_MEM_FLG_EXT_TOP	1
+
+struct tag_serial {
+	u32 version;
+	u32 enable;
+	u64 addr;
+	u32 baudrate;
+	u32 m_mode;
+	u32 id;
+	u32 reserved[2];
+	u32 hash;
+} __packed;
+
+struct tag_bootdev {
+	u32 version;
+	u32 devtype;
+	u32 devnum;
+	u32 mode;
+	u32 sdupdate;
+	u32 reserved[6];
+	u32 hash;
+} __packed;
+
+struct tag_ddr_mem {
+	u32 count;
+	u32 version;
+	u64 bank[20];
+	u32 flags;
+	u32 data[2];
+	u32 hash;
+} __packed;
+
+struct tag_tos_mem {
+	u32 version;
+	struct {
+		char name[8];
+		u64 phy_addr;
+		u32 size;
+		u32 flags;
+	} tee_mem;
+
+	struct {
+		char name[8];
+		u64 phy_addr;
+		u32 size;
+		u32 flags;
+	} drm_mem;
+
+	u64 reserved[7];
+	u32 reserved1;
+	u32 hash;
+} __packed;
+
+struct tag_atf_mem {
+	u32 version;
+	u64 phy_addr;
+	u32 size;
+	u32 flags;
+	u32 reserved[2];
+	u32 hash;
+} __packed;
+
+struct tag_pub_key {
+	u32 version;
+	u32 len;
+	u8  data[768];	/* u32 rsa_n[64], rsa_e[64], rsa_c[64] */
+	u32 flag;
+	u32 reserved[5];
+	u32 hash;
+} __packed;
+
+struct tag_ram_partition {
+	u32 version;
+	u32 count;
+	u32 reserved[4];
+
+	struct {
+		char name[16];
+		u64 start;
+		u64 size;
+	} part[6];
+
+	u32 reserved1[3];
+	u32 hash;
+} __packed;
+
+struct tag_soc_info {
+	u32 version;
+	u32 name;	/* Hex: 0x3288, 0x3399... */
+	u32 flags;
+	u32 reserved[6];
+	u32 hash;
+} __packed;
+
+struct tag_boot1p {
+	u32 version;
+	u32 param[8];
+	u32 reserved[4];
+	u32 hash;
+} __packed;
+
+struct tag_core {
+	u32 flags;
+	u32 pagesize;
+	u32 rootdev;
+} __packed;
+
+struct tag_header {
+	u32 size;	/* bytes = size * 4 */
+	u32 magic;
+} __packed;
+
+/* Must be 4 bytes align */
+struct tag {
+	struct tag_header hdr;
+	union {
+		struct tag_core		core;
+		struct tag_serial	serial;
+		struct tag_bootdev	bootdev;
+		struct tag_ddr_mem	ddr_mem;
+		struct tag_tos_mem	tos_mem;
+		struct tag_ram_partition ram_part;
+		struct tag_atf_mem	atf_mem;
+		struct tag_pub_key	pub_key;
+		struct tag_soc_info	soc;
+		struct tag_boot1p	boot1p;
+	} u;
+} __aligned(4);
+
+#define tag_next(t)	((struct tag *)((u32 *)(t) + (t)->hdr.size))
+#define tag_size(type)	((sizeof(struct tag_header) + sizeof(struct type)) >> 2)
+#define for_each_tag(t, base)		\
+	for (t = base; t->hdr.size; t = tag_next(t))
+/*
+ * Destroy atags
+ *
+ * first pre-loader who creates atags must call it before atags_set_tag(),
+ * because atags_set_tag() may detect last valid and existence ATAG_CORE
+ * tag in memory and lead a wrong setup, that is not what we expect.
+ */
+void atags_destroy(void);
+
+/*
+ * atags_set_tag - set tag data
+ *
+ * @magic: tag magic, i.e. ATAG_SERIAL, ATAG_BOOTDEV, ....
+ * @tagdata: core data of struct, i.e. struct tag_serial/tag_bootdev ...
+ *
+ * return: 0 on success, others failed.
+ */
+int atags_set_tag(u32 magic, void *tagdata);
+
+/*
+ * atags_get_tag - get tag by tag magic
+ *
+ * @magic: tag magic, i.e. ATAG_SERIAL, ATAG_BOOTDEV, ...
+ *
+ * return: NULL on failed, otherwise return the tag that we want.
+ */
+struct tag *atags_get_tag(u32 magic);
+
+/*
+ * atags_is_available - check if atags is available, used for second or
+ *			later pre-loaders.
+ *
+ * return: 0 is not available, otherwise available.
+ */
+int atags_is_available(void);
+
+/*
+ * atags_overflow - check if atags is overflow
+ *
+ * return: 0 if not overflow, otherwise overflow.
+ */
+int atags_overflow(struct tag *t);
+
+/*
+ * atags_bad_magic - check if atags magic is invalid.
+ *
+ * return: 1 if invalid, otherwise valid.
+ */
+int atags_bad_magic(u32 magic);
+
+#ifdef CONFIG_SPL_BUILD
+/*
+ * get_bootdev_by_brom_bootsource
+ *
+ * @magic: void
+ *
+ * return: boootdev, else 0 fail.
+ */
+int get_bootdev_by_brom_bootsource(void);
+
+/*
+ * atags_set_bootdev_by_brom_bootsource
+ *
+ * @magic: void
+ *
+ * return: 0 success, others fail.
+ */
+int atags_set_bootdev_by_brom_bootsource(void);
+
+/*
+ * get_bootdev_by_spl_bootdevice
+ *
+ * @bootdevice
+ *
+ * return: boootdev, else -ENODEV fail.
+ */
+int get_bootdev_by_spl_bootdevice(int bootdevice);
+
+/*
+ * atags_set_bootdev_by_spl_bootdevice
+ *
+ * @bootdevice
+ *
+ * return: 0 success, others fail.
+ */
+int atags_set_bootdev_by_spl_bootdevice(int bootdevice);
+
+/*
+ * atags_set_pub_key
+ *
+ * @data: public key data
+ * @len: public key len
+ * @flag: indicate the pulic key hash is burned or not
+ *
+ * return: 0 success, others fail.
+ */
+int atags_set_pub_key(void *data, int len, int flag);
+#endif
+
+#if CONFIG_IS_ENABLED(TINY_FRAMEWORK) &&		\
+	!CONFIG_IS_ENABLED(LIBGENERIC_SUPPORT) &&	\
+	!CONFIG_IS_ENABLED(USE_ARCH_MEMSET)
+void *memset(void *s, int c, size_t count);
+#endif
+
+#if CONFIG_IS_ENABLED(TINY_FRAMEWORK) &&		\
+	!CONFIG_IS_ENABLED(LIBGENERIC_SUPPORT) &&	\
+	!CONFIG_IS_ENABLED(USE_ARCH_MEMCPY)
+void *memcpy(void *dest, const void *src, size_t count);
+#endif
+
+#endif
diff --git a/arch/arm/mach-rockchip/Kconfig b/arch/arm/mach-rockchip/Kconfig
index bba332098f..d0c22ae7cc 100644
--- a/arch/arm/mach-rockchip/Kconfig
+++ b/arch/arm/mach-rockchip/Kconfig
@@ -525,6 +525,14 @@ config ROCKCHIP_SPI_IMAGE
 	  option to produce a SPI-flash image containing U-Boot. The image
 	  is built by binman. U-Boot sits near the start of the image.
 
+config ROCKCHIP_PRELOADER_ATAGS
+	bool "Rockchip pre-loader atags"
+	default y if ARCH_ROCKCHIP
+	help
+	  This enable support Rockchip atags among pre-loaders, i.e. ddr, miniloader, ATF,
+	  tos, U-Boot, etc. It delivers boot and configure information, shared with pre-loaders
+	  and finally ends with U-Boot.
+
 config LNX_KRNL_IMG_TEXT_OFFSET_BASE
 	default TEXT_BASE
 
diff --git a/arch/arm/mach-rockchip/Makefile b/arch/arm/mach-rockchip/Makefile
index 1dc92066bb..c4978d5257 100644
--- a/arch/arm/mach-rockchip/Makefile
+++ b/arch/arm/mach-rockchip/Makefile
@@ -48,6 +48,7 @@ obj-$(CONFIG_ROCKCHIP_RK3588) += rk3588/
 obj-$(CONFIG_ROCKCHIP_RV1108) += rv1108/
 obj-$(CONFIG_ROCKCHIP_RV1126) += rv1126/
 
+obj-$(CONFIG_ROCKCHIP_PRELOADER_ATAGS) += rk_atags.o
 # Clear out SPL objects, in case this is a TPL build
 obj-spl-$(CONFIG_TPL_BUILD) =
 
diff --git a/arch/arm/mach-rockchip/rk_atags.c b/arch/arm/mach-rockchip/rk_atags.c
new file mode 100644
index 0000000000..4f521d45e8
--- /dev/null
+++ b/arch/arm/mach-rockchip/rk_atags.c
@@ -0,0 +1,388 @@
+// SPDX-License-Identifier:     GPL-2.0+
+/*
+ * (C) Copyright 2018 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch-rockchip/bootrom.h>
+#include <asm/arch-rockchip/rk_atags.h>
+#if CONFIG_IS_ENABLED(TINY_FRAMEWORK)
+#include <debug_uart.h>
+#endif
+
+#define HASH_LEN	sizeof(u32)
+
+#if defined(CONFIG_SPL_BUILD) && !defined(CONFIG_TPL_BUILD)
+/*
+ * The array is used to transform rom bootsource type to rk atags boot type.
+ */
+static int bootdev_map[] = {
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_NAND,
+	BOOT_TYPE_EMMC,
+	BOOT_TYPE_SPI_NOR,
+	BOOT_TYPE_SPI_NAND,
+	BOOT_TYPE_SD0,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN
+};
+
+static int spl_bootdev_map[] = {
+	BOOT_TYPE_RAM,
+	BOOT_TYPE_EMMC,
+	BOOT_TYPE_SD0,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_NAND,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_UNKNOWN,
+	BOOT_TYPE_MTD_BLK_NAND,
+	BOOT_TYPE_MTD_BLK_SPI_NAND,
+	BOOT_TYPE_MTD_BLK_SPI_NOR
+};
+#endif
+
+#if CONFIG_IS_ENABLED(TINY_FRAMEWORK) &&		\
+	!CONFIG_IS_ENABLED(LIBGENERIC_SUPPORT) &&	\
+	!CONFIG_IS_ENABLED(USE_ARCH_MEMSET)
+/**
+ * memset - Fill a region of memory with the given value
+ * @s: Pointer to the start of the area.
+ * @c: The byte to fill the area with
+ * @count: The size of the area.
+ *
+ * Do not use memset() to access IO space, use memset_io() instead.
+ */
+void *memset(void *s, int c, size_t count)
+{
+	unsigned long *sl = (unsigned long *)s;
+	char *s8;
+
+	s8 = (char *)sl;
+	while (count--)
+		*s8++ = c;
+
+	return s;
+}
+#endif
+
+#if CONFIG_IS_ENABLED(TINY_FRAMEWORK) &&		\
+	!CONFIG_IS_ENABLED(LIBGENERIC_SUPPORT) &&	\
+	!CONFIG_IS_ENABLED(USE_ARCH_MEMCPY)
+/**
+ * memcpy - Copy one area of memory to another
+ * @dest: Where to copy to
+ * @src: Where to copy from
+ * @count: The size of the area.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+void *memcpy(void *dest, const void *src, size_t count)
+{
+	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
+	char *d8, *s8;
+
+	if (src == dest)
+		return dest;
+
+	/* while all data is aligned (common case), copy a word at a time */
+	if ((((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
+		while (count >= sizeof(*dl)) {
+			*dl++ = *sl++;
+			count -= sizeof(*dl);
+		}
+	}
+	/* copy the reset one byte at a time */
+	d8 = (char *)dl;
+	s8 = (char *)sl;
+	while (count--)
+		*d8++ = *s8++;
+
+	return dest;
+}
+#endif
+
+static u32 js_hash(void *buf, u32 len)
+{
+	u32 i, hash = 0x47C6A7E6;
+	char *data = buf;
+
+	if (!buf || !len)
+		return hash;
+
+	for (i = 0; i < len; i++)
+		hash ^= ((hash << 5) + data[i] + (hash >> 2));
+
+	return hash;
+}
+
+int atags_bad_magic(u32 magic)
+{
+	bool bad;
+
+	bad = ((magic != ATAG_CORE) &&
+	       (magic != ATAG_NONE) &&
+	       (magic < ATAG_SERIAL || magic > ATAG_MAX));
+	if (bad) {
+#if !CONFIG_IS_ENABLED(TINY_FRAMEWORK)
+		printf("Magic(%x) is not support\n", magic);
+#else
+		printascii("Magic is not support\n");
+#endif
+	}
+
+	return bad;
+}
+
+static int inline atags_size_overflow(struct tag *t, u32 tag_size)
+{
+	return (unsigned long)t + (tag_size << 2) - ATAGS_PHYS_BASE > ATAGS_SIZE;
+}
+
+int atags_overflow(struct tag *t)
+{
+	bool overflow;
+
+	overflow = atags_size_overflow(t, 0) ||
+		   atags_size_overflow(t, t->hdr.size);
+	if (overflow) {
+#if !CONFIG_IS_ENABLED(TINY_FRAMEWORK)
+		printf("Tag is overflow\n");
+#else
+		printascii("Tag is overflow\n");
+#endif
+	}
+
+	return overflow;
+}
+
+int atags_is_available(void)
+{
+	struct tag *t = (struct tag *)ATAGS_PHYS_BASE;
+
+	return (t->hdr.magic == ATAG_CORE);
+}
+
+int atags_set_tag(u32 magic, void *tagdata)
+{
+	u32 length, size = 0, hash;
+	struct tag *t = (struct tag *)ATAGS_PHYS_BASE;
+
+#if !defined(CONFIG_TPL_BUILD) && !defined(CONFIG_FPGA_ROCKCHIP)
+	if (!atags_is_available())
+		return -EPERM;
+#endif
+
+	if (!tagdata)
+		return -ENODATA;
+
+	if (atags_bad_magic(magic))
+		return -EINVAL;
+
+	/* Not allowed to be set by user directly, so do nothing */
+	if ((magic == ATAG_CORE) || (magic == ATAG_NONE))
+		return -EPERM;
+
+	/* If not initialized, setup now! */
+	if (t->hdr.magic != ATAG_CORE) {
+		t->hdr.magic = ATAG_CORE;
+		t->hdr.size = tag_size(tag_core);
+		t->u.core.flags = 0;
+		t->u.core.pagesize = 0;
+		t->u.core.rootdev = 0;
+
+		t = tag_next(t);
+	} else {
+		/* Find the end, and use it as a new tag */
+		for_each_tag(t, (struct tag *)ATAGS_PHYS_BASE) {
+			if (atags_overflow(t))
+				return -EINVAL;
+
+			if (atags_bad_magic(t->hdr.magic))
+				return -EINVAL;
+
+			/* This is an old tag, override it */
+			if (t->hdr.magic == magic)
+				break;
+
+			if (t->hdr.magic == ATAG_NONE)
+				break;
+		}
+	}
+
+	/* Initialize new tag */
+	switch (magic) {
+	case ATAG_SERIAL:
+		size = tag_size(tag_serial);
+		break;
+	case ATAG_BOOTDEV:
+		size = tag_size(tag_bootdev);
+		break;
+	case ATAG_TOS_MEM:
+		size = tag_size(tag_tos_mem);
+		break;
+	case ATAG_DDR_MEM:
+		size = tag_size(tag_ddr_mem);
+		break;
+	case ATAG_RAM_PARTITION:
+		size = tag_size(tag_ram_partition);
+		break;
+	case ATAG_ATF_MEM:
+		size = tag_size(tag_atf_mem);
+		break;
+	case ATAG_PUB_KEY:
+		size = tag_size(tag_pub_key);
+		break;
+	case ATAG_SOC_INFO:
+		size = tag_size(tag_soc_info);
+		break;
+	case ATAG_BOOT1_PARAM:
+		size = tag_size(tag_boot1p);
+		break;
+	};
+
+	if (!size)
+		return -EINVAL;
+
+	if (atags_size_overflow(t, size))
+		return -ENOMEM;
+
+	/* It's okay to setup a new tag */
+	t->hdr.magic = magic;
+	t->hdr.size = size;
+	length = (t->hdr.size << 2) - sizeof(struct tag_header) - HASH_LEN;
+	memcpy(&t->u, (char *)tagdata, length);
+	hash = js_hash(t, (size << 2) - HASH_LEN);
+	memcpy((char *)&t->u + length, &hash, HASH_LEN);
+
+	/* Next tag */
+	t = tag_next(t);
+
+	/* Setup done */
+	t->hdr.magic = ATAG_NONE;
+	t->hdr.size = 0;
+
+	return 0;
+}
+
+#ifndef CONFIG_TPL_BUILD
+struct tag *atags_get_tag(u32 magic)
+{
+	u32 *hash, calc_hash, size;
+	struct tag *t;
+
+	if (!atags_is_available())
+		return NULL;
+
+	for_each_tag(t, (struct tag *)ATAGS_PHYS_BASE) {
+		if (atags_overflow(t))
+			return NULL;
+
+		if (atags_bad_magic(t->hdr.magic))
+			return NULL;
+
+		if (t->hdr.magic != magic)
+			continue;
+
+		size = t->hdr.size;
+		hash = (u32 *)((ulong)t + (size << 2) - HASH_LEN);
+		if (!*hash) {
+			debug("No hash, magic(%x)\n", magic);
+			return t;
+		} else {
+			calc_hash = js_hash(t, (size << 2) - HASH_LEN);
+			if (calc_hash == *hash) {
+				debug("Hash okay, magic(%x)\n", magic);
+				return t;
+			} else {
+				debug("Hash bad, magic(%x), orgHash=%x, nowHash=%x\n",
+				      magic, *hash, calc_hash);
+				return NULL;
+			}
+		}
+	}
+
+	return NULL;
+}
+#else
+struct tag *atags_get_tag(u32 magic) { return NULL; }
+#endif
+
+#if defined(CONFIG_SPL_BUILD) && !defined(CONFIG_TPL_BUILD)
+int get_bootdev_by_brom_bootsource(void)
+{
+	int bootsource = 0;
+
+	bootsource = readl(BROM_BOOTSOURCE_ID_ADDR);
+	if (bootsource > ARRAY_SIZE(bootdev_map) - 1 || bootsource < 0)
+		return 0;
+	else
+		return bootdev_map[bootsource];
+}
+
+int atags_set_bootdev_by_brom_bootsource(void)
+{
+	struct tag_bootdev boot_dev;
+
+	memset(&boot_dev, 0, sizeof(struct tag_bootdev));
+	boot_dev.devtype = get_bootdev_by_brom_bootsource();
+
+	return atags_set_tag(ATAG_BOOTDEV, &boot_dev);
+}
+
+int get_bootdev_by_spl_bootdevice(int bootdevice)
+{
+	if (bootdevice > ARRAY_SIZE(spl_bootdev_map) - 1)
+		return -ENODEV;
+
+	return spl_bootdev_map[bootdevice];
+}
+
+int atags_set_bootdev_by_spl_bootdevice(int bootdevice)
+{
+	struct tag_bootdev boot_dev;
+
+	memset(&boot_dev, 0, sizeof(struct tag_bootdev));
+	boot_dev.devtype = get_bootdev_by_spl_bootdevice(bootdevice);
+	if (boot_dev.devtype < 0)
+		boot_dev.devtype = BOOT_TYPE_UNKNOWN;
+
+	return atags_set_tag(ATAG_BOOTDEV, &boot_dev);
+}
+
+int atags_set_pub_key(void *data, int len, int flag)
+{
+	struct tag_pub_key pub_key;
+
+	if (!data)
+		return -ENOMEM;
+
+	memset(&pub_key, 0, sizeof(struct tag_pub_key));
+	pub_key.len = len;
+	pub_key.flag = flag;
+	memcpy(pub_key.data, data, len);
+
+	return atags_set_tag(ATAG_PUB_KEY, &pub_key);
+}
+#endif
+
+void atags_destroy(void)
+{
+	if (atags_is_available())
+		memset((char *)ATAGS_PHYS_BASE, 0, sizeof(struct tag));
+}
+
diff --git a/arch/arm/mach-rockchip/sdram.c b/arch/arm/mach-rockchip/sdram.c
index 1d17a740ad..636f5d6f18 100644
--- a/arch/arm/mach-rockchip/sdram.c
+++ b/arch/arm/mach-rockchip/sdram.c
@@ -64,6 +64,7 @@ int dram_init_banksize(void)
 		gd->bd->bi_dram[1].start = tos_parameter->tee_mem.phy_addr +
 					tos_parameter->tee_mem.size;
 		gd->bd->bi_dram[1].size = top - gd->bd->bi_dram[1].start;
+		gd->bd->bi_dram[0].size = gd->bd->bi_dram[1].start + gd->bd->bi_dram[1].size;
 	} else {
 		gd->bd->bi_dram[0].start = CFG_SYS_SDRAM_BASE;
 		gd->bd->bi_dram[0].size = 0x8400000;
diff --git a/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-1056.inc b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-1056.inc
new file mode 100644
index 0000000000..295b0871e0
--- /dev/null
+++ b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-1056.inc
@@ -0,0 +1,75 @@
+{
+	{
+		{
+			.rank = 0x1,
+			.col = 0xA,
+			.bk = 0x2,
+			.bw = 0x1,
+			.dbw = 0x0,
+			.row_3_4 = 0x0,
+			.cs0_row = 0x11,
+			.cs1_row = 0x0,
+			.cs0_high16bit_row = 0x11,
+			.cs1_high16bit_row = 0x0,
+			.ddrconfig = 0
+		},
+		{
+			{0x561d1219},
+			{0x10030703},
+			{0x00000002},
+			{0x00001111},
+			{0x0000000c},
+			{0x0000034b},
+			0x000000ff
+		}
+	},
+	{
+		.ddr_freq = 1056,	/* clock rate(MHz) */
+		.dramtype = DDR4,
+		.num_channels = 1,
+		.stride = 0,
+		.odt = 1
+	},
+	{
+		{
+			{0x00000000, 0x43041010},	/* MSTR */
+			{0x00000064, 0x008000b9},	/* RFSHTMG */
+			{0x000000d0, 0x00020103},	/* INIT0 */
+			{0x000000d4, 0x00690000},	/* INIT1 */
+			{0x000000d8, 0x00000100},	/* INIT2 */
+			{0x000000dc, 0x07340401},	/* INIT3 */
+			{0x000000e0, 0x00100000},	/* INIT4 */
+			{0x000000e4, 0x00110000},	/* INIT5 */
+			{0x000000e8, 0x00000420},	/* INIT6 */
+			{0x000000ec, 0x00000800},	/* INIT7 */
+			{0x000000f4, 0x000f011f},	/* RANKCTL */
+			{0x00000100, 0x0f102411},	/* DRAMTMG0 */
+			{0x00000104, 0x0004041a},	/* DRAMTMG1 */
+			{0x00000108, 0x0608060d},	/* DRAMTMG2 */
+			{0x0000010c, 0x0040400c},	/* DRAMTMG3 */
+			{0x00000110, 0x08030409},	/* DRAMTMG4 */
+			{0x00000114, 0x06060403},	/* DRAMTMG5 */
+			{0x00000120, 0x07070d07},	/* DRAMTMG8 */
+			{0x00000124, 0x00020309},	/* DRAMTMG9 */
+			{0x00000180, 0x01000040},	/* ZQCTL0 */
+			{0x00000184, 0x00000000},	/* ZQCTL1 */
+			{0x00000190, 0x07060004},	/* DFITMG0 */
+			{0x00000198, 0x07000101},	/* DFILPCFG0 */
+			{0x000001a0, 0xc0400003},	/* DFIUPD0 */
+			{0x00000240, 0x06000614},	/* ODTCFG */
+			{0x00000244, 0x00000201},	/* ODTMAP */
+			{0x00000250, 0x00001f00},	/* SCHED */
+			{0x00000490, 0x00000001},	/* PCTRL_0 */
+			{0xffffffff, 0xffffffff}
+		}
+	},
+	{
+		{
+			{0x00000004, 0x0000008c},	/* PHYREG01 */
+			{0x00000014, 0x00000010},	/* PHYREG05 */
+			{0x00000018, 0x00000000},	/* PHYREG06 */
+			{0x0000001c, 0x0000000b},	/* PHYREG07 */
+			{0xffffffff, 0xffffffff}
+		}
+	}
+},
diff --git a/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-328.inc b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-328.inc
new file mode 100644
index 0000000000..4b424fb440
--- /dev/null
+++ b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-328.inc
@@ -0,0 +1,75 @@
+{
+	{
+		{
+			.rank = 0x1,
+			.col = 0xA,
+			.bk = 0x2,
+			.bw = 0x1,
+			.dbw = 0x0,
+			.row_3_4 = 0x0,
+			.cs0_row = 0x11,
+			.cs1_row = 0x0,
+			.cs0_high16bit_row = 0x11,
+			.cs1_high16bit_row = 0x0,
+			.ddrconfig = 0
+		},
+		{
+			{0x4d110a08},
+			{0x06020501},
+			{0x00000002},
+			{0x00001111},
+			{0x0000000c},
+			{0x00000232},
+			0x000000ff
+		}
+	},
+	{
+		.ddr_freq = 328,	/* clock rate(MHz) */
+		.dramtype = DDR4,
+		.num_channels = 1,
+		.stride = 0,
+		.odt = 0
+	},
+	{
+		{
+			{0x00000000, 0x43049010},	/* MSTR */
+			{0x00000064, 0x0027003a},	/* RFSHTMG */
+			{0x000000d0, 0x00020052},	/* INIT0 */
+			{0x000000d4, 0x00220000},	/* INIT1 */
+			{0x000000d8, 0x00000100},	/* INIT2 */
+			{0x000000dc, 0x00040000},	/* INIT3 */
+			{0x000000e0, 0x00000000},	/* INIT4 */
+			{0x000000e4, 0x00110000},	/* INIT5 */
+			{0x000000e8, 0x00000420},	/* INIT6 */
+			{0x000000ec, 0x00000400},	/* INIT7 */
+			{0x000000f4, 0x000f011f},	/* RANKCTL */
+			{0x00000100, 0x09060b06},	/* DRAMTMG0 */
+			{0x00000104, 0x00020209},	/* DRAMTMG1 */
+			{0x00000108, 0x0505040a},	/* DRAMTMG2 */
+			{0x0000010c, 0x0040400c},	/* DRAMTMG3 */
+			{0x00000110, 0x05030206},	/* DRAMTMG4 */
+			{0x00000114, 0x03030202},	/* DRAMTMG5 */
+			{0x00000120, 0x03030b03},	/* DRAMTMG8 */
+			{0x00000124, 0x00020208},	/* DRAMTMG9 */
+			{0x00000180, 0x01000040},	/* ZQCTL0 */
+			{0x00000184, 0x00000000},	/* ZQCTL1 */
+			{0x00000190, 0x07030003},	/* DFITMG0 */
+			{0x00000198, 0x07000101},	/* DFILPCFG0 */
+			{0x000001a0, 0xc0400003},	/* DFIUPD0 */
+			{0x00000240, 0x06000604},	/* ODTCFG */
+			{0x00000244, 0x00000201},	/* ODTMAP */
+			{0x00000250, 0x00001f00},	/* SCHED */
+			{0x00000490, 0x00000001},	/* PCTRL_0 */
+			{0xffffffff, 0xffffffff}
+		}
+	},
+	{
+		{
+			{0x00000004, 0x0000008c},	/* PHYREG01 */
+			{0x00000014, 0x0000000a},	/* PHYREG05 */
+			{0x00000018, 0x00000000},	/* PHYREG06 */
+			{0x0000001c, 0x00000009},	/* PHYREG07 */
+			{0xffffffff, 0xffffffff}
+		}
+	}
+},
diff --git a/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-396.inc b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-396.inc
new file mode 100644
index 0000000000..980be8cf18
--- /dev/null
+++ b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-396.inc
@@ -0,0 +1,75 @@
+{
+	{
+		{
+			.rank = 0x1,
+			.col = 0xA,
+			.bk = 0x2,
+			.bw = 0x1,
+			.dbw = 0x0,
+			.row_3_4 = 0x0,
+			.cs0_row = 0x11,
+			.cs1_row = 0x0,
+			.cs0_high16bit_row = 0x11,
+			.cs1_high16bit_row = 0x0,
+			.ddrconfig = 0
+		},
+		{
+			{0x4d110a0a},
+			{0x07020501},
+			{0x00000002},
+			{0x00001111},
+			{0x0000000c},
+			{0x00000232},
+			0x000000ff
+		}
+	},
+	{
+		.ddr_freq = 396,	/* clock rate(MHz) */
+		.dramtype = DDR4,
+		.num_channels = 1,
+		.stride = 0,
+		.odt = 0
+	},
+	{
+		{
+			{0x00000000, 0x43049010},	/* MSTR */
+			{0x00000064, 0x00300046},	/* RFSHTMG */
+			{0x000000d0, 0x00020062},	/* INIT0 */
+			{0x000000d4, 0x00280000},	/* INIT1 */
+			{0x000000d8, 0x00000100},	/* INIT2 */
+			{0x000000dc, 0x00040000},	/* INIT3 */
+			{0x000000e0, 0x00000000},	/* INIT4 */
+			{0x000000e4, 0x00110000},	/* INIT5 */
+			{0x000000e8, 0x00000420},	/* INIT6 */
+			{0x000000ec, 0x00000400},	/* INIT7 */
+			{0x000000f4, 0x000f011f},	/* RANKCTL */
+			{0x00000100, 0x09070d07},	/* DRAMTMG0 */
+			{0x00000104, 0x0002020a},	/* DRAMTMG1 */
+			{0x00000108, 0x0505040a},	/* DRAMTMG2 */
+			{0x0000010c, 0x0040400c},	/* DRAMTMG3 */
+			{0x00000110, 0x05030206},	/* DRAMTMG4 */
+			{0x00000114, 0x03030202},	/* DRAMTMG5 */
+			{0x00000120, 0x04040b04},	/* DRAMTMG8 */
+			{0x00000124, 0x00020208},	/* DRAMTMG9 */
+			{0x00000180, 0x01000040},	/* ZQCTL0 */
+			{0x00000184, 0x00000000},	/* ZQCTL1 */
+			{0x00000190, 0x07030003},	/* DFITMG0 */
+			{0x00000198, 0x07000101},	/* DFILPCFG0 */
+			{0x000001a0, 0xc0400003},	/* DFIUPD0 */
+			{0x00000240, 0x06000604},	/* ODTCFG */
+			{0x00000244, 0x00000201},	/* ODTMAP */
+			{0x00000250, 0x00001f00},	/* SCHED */
+			{0x00000490, 0x00000001},	/* PCTRL_0 */
+			{0xffffffff, 0xffffffff}
+		}
+	},
+	{
+		{
+			{0x00000004, 0x0000008c},	/* PHYREG01 */
+			{0x00000014, 0x0000000a},	/* PHYREG05 */
+			{0x00000018, 0x00000000},	/* PHYREG06 */
+			{0x0000001c, 0x00000009},	/* PHYREG07 */
+			{0xffffffff, 0xffffffff}
+		}
+	}
+},
diff --git a/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-528.inc b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-528.inc
new file mode 100644
index 0000000000..3bde055e8d
--- /dev/null
+++ b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-528.inc
@@ -0,0 +1,75 @@
+{
+	{
+		{
+			.rank = 0x1,
+			.col = 0xA,
+			.bk = 0x2,
+			.bw = 0x1,
+			.dbw = 0x0,
+			.row_3_4 = 0x0,
+			.cs0_row = 0x11,
+			.cs1_row = 0x0,
+			.cs0_high16bit_row = 0x11,
+			.cs1_high16bit_row = 0x0,
+			.ddrconfig = 0
+		},
+		{
+			{0x4d120a0d},
+			{0x09020501},
+			{0x00000002},
+			{0x00001111},
+			{0x0000000c},
+			{0x00000232},
+			0x000000ff
+		}
+	},
+	{
+		.ddr_freq = 528,	/* clock rate(MHz) */
+		.dramtype = DDR4,
+		.num_channels = 1,
+		.stride = 0,
+		.odt = 0
+	},
+	{
+		{
+			{0x00000000, 0x43049010},	/* MSTR */
+			{0x00000064, 0x0040005d},	/* RFSHTMG */
+			{0x000000d0, 0x00020082},	/* INIT0 */
+			{0x000000d4, 0x00350000},	/* INIT1 */
+			{0x000000d8, 0x00000100},	/* INIT2 */
+			{0x000000dc, 0x00040000},	/* INIT3 */
+			{0x000000e0, 0x00000000},	/* INIT4 */
+			{0x000000e4, 0x00110000},	/* INIT5 */
+			{0x000000e8, 0x00000420},	/* INIT6 */
+			{0x000000ec, 0x00000400},	/* INIT7 */
+			{0x000000f4, 0x000f011f},	/* RANKCTL */
+			{0x00000100, 0x0a0a1209},	/* DRAMTMG0 */
+			{0x00000104, 0x0002020e},	/* DRAMTMG1 */
+			{0x00000108, 0x0505040a},	/* DRAMTMG2 */
+			{0x0000010c, 0x0040400c},	/* DRAMTMG3 */
+			{0x00000110, 0x05030206},	/* DRAMTMG4 */
+			{0x00000114, 0x03030202},	/* DRAMTMG5 */
+			{0x00000120, 0x04040b04},	/* DRAMTMG8 */
+			{0x00000124, 0x00020208},	/* DRAMTMG9 */
+			{0x00000180, 0x01000040},	/* ZQCTL0 */
+			{0x00000184, 0x00000000},	/* ZQCTL1 */
+			{0x00000190, 0x07030003},	/* DFITMG0 */
+			{0x00000198, 0x07000101},	/* DFILPCFG0 */
+			{0x000001a0, 0xc0400003},	/* DFIUPD0 */
+			{0x00000240, 0x06000604},	/* ODTCFG */
+			{0x00000244, 0x00000201},	/* ODTMAP */
+			{0x00000250, 0x00001f00},	/* SCHED */
+			{0x00000490, 0x00000001},	/* PCTRL_0 */
+			{0xffffffff, 0xffffffff}
+		}
+	},
+	{
+		{
+			{0x00000004, 0x0000008c},	/* PHYREG01 */
+			{0x00000014, 0x0000000a},	/* PHYREG05 */
+			{0x00000018, 0x00000000},	/* PHYREG06 */
+			{0x0000001c, 0x00000009},	/* PHYREG07 */
+			{0xffffffff, 0xffffffff}
+		}
+	}
+},
diff --git a/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-664.inc b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-664.inc
new file mode 100644
index 0000000000..c9341166d6
--- /dev/null
+++ b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-664.inc
@@ -0,0 +1,75 @@
+{
+	{
+		{
+			.rank = 0x1,
+			.col = 0xA,
+			.bk = 0x2,
+			.bw = 0x1,
+			.dbw = 0x0,
+			.row_3_4 = 0x0,
+			.cs0_row = 0x11,
+			.cs1_row = 0x0,
+			.cs0_high16bit_row = 0x11,
+			.cs1_high16bit_row = 0x0,
+			.ddrconfig = 0
+		},
+		{
+			{0x4d130a11},
+			{0x0c020501},
+			{0x00000002},
+			{0x00001111},
+			{0x0000000c},
+			{0x0000023a},
+			0x000000ff
+		}
+	},
+	{
+		.ddr_freq = 664,	/* clock rate(MHz) */
+		.dramtype = DDR4,
+		.num_channels = 1,
+		.stride = 0,
+		.odt = 1
+	},
+	{
+		{
+			{0x00000000, 0x43041010},	/* MSTR */
+			{0x00000064, 0x00500075},	/* RFSHTMG */
+			{0x000000d0, 0x000200a4},	/* INIT0 */
+			{0x000000d4, 0x00420000},	/* INIT1 */
+			{0x000000d8, 0x00000100},	/* INIT2 */
+			{0x000000dc, 0x01040401},	/* INIT3 */
+			{0x000000e0, 0x00000000},	/* INIT4 */
+			{0x000000e4, 0x00110000},	/* INIT5 */
+			{0x000000e8, 0x00000420},	/* INIT6 */
+			{0x000000ec, 0x00000400},	/* INIT7 */
+			{0x000000f4, 0x000f011f},	/* RANKCTL */
+			{0x00000100, 0x0b0c160c},	/* DRAMTMG0 */
+			{0x00000104, 0x00020211},	/* DRAMTMG1 */
+			{0x00000108, 0x0505040a},	/* DRAMTMG2 */
+			{0x0000010c, 0x0040400c},	/* DRAMTMG3 */
+			{0x00000110, 0x05030306},	/* DRAMTMG4 */
+			{0x00000114, 0x04040302},	/* DRAMTMG5 */
+			{0x00000120, 0x05050b05},	/* DRAMTMG8 */
+			{0x00000124, 0x00020208},	/* DRAMTMG9 */
+			{0x00000180, 0x01000040},	/* ZQCTL0 */
+			{0x00000184, 0x00000000},	/* ZQCTL1 */
+			{0x00000190, 0x07030003},	/* DFITMG0 */
+			{0x00000198, 0x07000101},	/* DFILPCFG0 */
+			{0x000001a0, 0xc0400003},	/* DFIUPD0 */
+			{0x00000240, 0x06000604},	/* ODTCFG */
+			{0x00000244, 0x00000201},	/* ODTMAP */
+			{0x00000250, 0x00001f00},	/* SCHED */
+			{0x00000490, 0x00000001},	/* PCTRL_0 */
+			{0xffffffff, 0xffffffff}
+		}
+	},
+	{
+		{
+			{0x00000004, 0x0000008c},	/* PHYREG01 */
+			{0x00000014, 0x0000000a},	/* PHYREG05 */
+			{0x00000018, 0x00000000},	/* PHYREG06 */
+			{0x0000001c, 0x00000009},	/* PHYREG07 */
+			{0xffffffff, 0xffffffff}
+		}
+	}
+},
diff --git a/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-784.inc b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-784.inc
new file mode 100644
index 0000000000..ef2e9347bf
--- /dev/null
+++ b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-784.inc
@@ -0,0 +1,75 @@
+{
+	{
+		{
+			.rank = 0x1,
+			.col = 0xA,
+			.bk = 0x2,
+			.bw = 0x1,
+			.dbw = 0x0,
+			.row_3_4 = 0x0,
+			.cs0_row = 0x11,
+			.cs1_row = 0x0,
+			.cs0_high16bit_row = 0x11,
+			.cs1_high16bit_row = 0x0,
+			.ddrconfig = 0
+		},
+		{
+			{0x50160d14},
+			{0x0e020502},
+			{0x00000002},
+			{0x00001111},
+			{0x0000000c},
+			{0x0000033a},
+			0x000000ff
+		}
+	},
+	{
+		.ddr_freq = 784,	/* clock rate(MHz) */
+		.dramtype = DDR4,
+		.num_channels = 1,
+		.stride = 0,
+		.odt = 1
+	},
+	{
+		{
+			{0x00000000, 0x43041010},	/* MSTR */
+			{0x00000064, 0x005f008a},	/* RFSHTMG */
+			{0x000000d0, 0x000200c1},	/* INIT0 */
+			{0x000000d4, 0x004e0000},	/* INIT1 */
+			{0x000000d8, 0x00000100},	/* INIT2 */
+			{0x000000dc, 0x03140401},	/* INIT3 */
+			{0x000000e0, 0x00000000},	/* INIT4 */
+			{0x000000e4, 0x00110000},	/* INIT5 */
+			{0x000000e8, 0x00000420},	/* INIT6 */
+			{0x000000ec, 0x00000400},	/* INIT7 */
+			{0x000000f4, 0x000f011f},	/* RANKCTL */
+			{0x00000100, 0x0c0e1a0e},	/* DRAMTMG0 */
+			{0x00000104, 0x00030314},	/* DRAMTMG1 */
+			{0x00000108, 0x0506050b},	/* DRAMTMG2 */
+			{0x0000010c, 0x0040400c},	/* DRAMTMG3 */
+			{0x00000110, 0x06030307},	/* DRAMTMG4 */
+			{0x00000114, 0x04040302},	/* DRAMTMG5 */
+			{0x00000120, 0x06060b06},	/* DRAMTMG8 */
+			{0x00000124, 0x00020308},	/* DRAMTMG9 */
+			{0x00000180, 0x01000040},	/* ZQCTL0 */
+			{0x00000184, 0x00000000},	/* ZQCTL1 */
+			{0x00000190, 0x07040003},	/* DFITMG0 */
+			{0x00000198, 0x07000101},	/* DFILPCFG0 */
+			{0x000001a0, 0xc0400003},	/* DFIUPD0 */
+			{0x00000240, 0x0600060c},	/* ODTCFG */
+			{0x00000244, 0x00000201},	/* ODTMAP */
+			{0x00000250, 0x00001f00},	/* SCHED */
+			{0x00000490, 0x00000001},	/* PCTRL_0 */
+			{0xffffffff, 0xffffffff}
+		}
+	},
+	{
+		{
+			{0x00000004, 0x0000008c},	/* PHYREG01 */
+			{0x00000014, 0x0000000c},	/* PHYREG05 */
+			{0x00000018, 0x00000000},	/* PHYREG06 */
+			{0x0000001c, 0x00000009},	/* PHYREG07 */
+			{0xffffffff, 0xffffffff}
+		}
+	}
+},
diff --git a/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-924.inc b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-924.inc
new file mode 100644
index 0000000000..acb33bd315
--- /dev/null
+++ b/drivers/ram/rockchip/sdram-rv1126-ddr4-detect-924.inc
@@ -0,0 +1,75 @@
+{
+	{
+		{
+			.rank = 0x1,
+			.col = 0xA,
+			.bk = 0x2,
+			.bw = 0x1,
+			.dbw = 0x0,
+			.row_3_4 = 0x0,
+			.cs0_row = 0x11,
+			.cs1_row = 0x0,
+			.cs0_high16bit_row = 0x11,
+			.cs1_high16bit_row = 0x0,
+			.ddrconfig = 0
+		},
+		{
+			{0x531a0f17},
+			{0x0e020603},
+			{0x00000002},
+			{0x00001111},
+			{0x0000000c},
+			{0x00000342},
+			0x000000ff
+		}
+	},
+	{
+		.ddr_freq = 924,	/* clock rate(MHz) */
+		.dramtype = DDR4,
+		.num_channels = 1,
+		.stride = 0,
+		.odt = 1
+	},
+	{
+		{
+			{0x00000000, 0x43041010},	/* MSTR */
+			{0x00000064, 0x007000a2},	/* RFSHTMG */
+			{0x000000d0, 0x000200e3},	/* INIT0 */
+			{0x000000d4, 0x005c0000},	/* INIT1 */
+			{0x000000d8, 0x00000100},	/* INIT2 */
+			{0x000000dc, 0x05240401},	/* INIT3 */
+			{0x000000e0, 0x00080000},	/* INIT4 */
+			{0x000000e4, 0x00110000},	/* INIT5 */
+			{0x000000e8, 0x00000420},	/* INIT6 */
+			{0x000000ec, 0x00000400},	/* INIT7 */
+			{0x000000f4, 0x000f011f},	/* RANKCTL */
+			{0x00000100, 0x0e0e1f10},	/* DRAMTMG0 */
+			{0x00000104, 0x00030317},	/* DRAMTMG1 */
+			{0x00000108, 0x0507050c},	/* DRAMTMG2 */
+			{0x0000010c, 0x0040400c},	/* DRAMTMG3 */
+			{0x00000110, 0x07030308},	/* DRAMTMG4 */
+			{0x00000114, 0x05050303},	/* DRAMTMG5 */
+			{0x00000120, 0x07070b07},	/* DRAMTMG8 */
+			{0x00000124, 0x00020309},	/* DRAMTMG9 */
+			{0x00000180, 0x01000040},	/* ZQCTL0 */
+			{0x00000184, 0x00000000},	/* ZQCTL1 */
+			{0x00000190, 0x07050003},	/* DFITMG0 */
+			{0x00000198, 0x07000101},	/* DFILPCFG0 */
+			{0x000001a0, 0xc0400003},	/* DFIUPD0 */
+			{0x00000240, 0x06000610},	/* ODTCFG */
+			{0x00000244, 0x00000201},	/* ODTMAP */
+			{0x00000250, 0x00001f00},	/* SCHED */
+			{0x00000490, 0x00000001},	/* PCTRL_0 */
+			{0xffffffff, 0xffffffff}
+		}
+	},
+	{
+		{
+			{0x00000004, 0x0000008c},	/* PHYREG01 */
+			{0x00000014, 0x0000000e},	/* PHYREG05 */
+			{0x00000018, 0x00000000},	/* PHYREG06 */
+			{0x0000001c, 0x0000000a},	/* PHYREG07 */
+			{0xffffffff, 0xffffffff}
+		}
+	}
+},
diff --git a/drivers/ram/rockchip/sdram_rv1126.c b/drivers/ram/rockchip/sdram_rv1126.c
index 9e1376a940..1c754eebb3 100644
--- a/drivers/ram/rockchip/sdram_rv1126.c
+++ b/drivers/ram/rockchip/sdram_rv1126.c
@@ -12,6 +12,7 @@
 #include <asm/io.h>
 #include <asm/arch-rockchip/clock.h>
 #include <asm/arch-rockchip/hardware.h>
+#include <asm/arch-rockchip/rk_atags.h>
 #include <asm/arch-rockchip/cru_rv1126.h>
 #include <asm/arch-rockchip/grf_rv1126.h>
 #include <asm/arch-rockchip/sdram_common.h>
@@ -76,6 +77,14 @@ struct rv1126_sdram_params sdram_configs[] = {
 # include	"sdram-rv1126-lpddr4-detect-784.inc"
 # include	"sdram-rv1126-lpddr4-detect-924.inc"
 # include	"sdram-rv1126-lpddr4-detect-1056.inc"
+#elif defined(CONFIG_RAM_ROCKCHIP_DDR4)
+# include	"sdram-rv1126-ddr4-detect-328.inc"
+# include	"sdram-rv1126-ddr4-detect-396.inc"
+# include	"sdram-rv1126-ddr4-detect-528.inc"
+# include	"sdram-rv1126-ddr4-detect-664.inc"
+# include	"sdram-rv1126-ddr4-detect-784.inc"
+# include	"sdram-rv1126-ddr4-detect-924.inc"
+# include	"sdram-rv1126-ddr4-detect-1056.inc"
 #else
 # include	"sdram-rv1126-ddr3-detect-328.inc"
 # include	"sdram-rv1126-ddr3-detect-396.inc"
@@ -2327,6 +2336,68 @@ static void enable_low_power(struct dram_info *dram,
 	setbits_le32(pctl_base + DDR_PCTL2_PWRCTL, (1 << 3));
 }
 
+static void ddr_set_atags(struct dram_info *dram,
+			  struct rv1126_sdram_params *sdram_params)
+{
+	struct sdram_cap_info *cap_info = &sdram_params->ch.cap_info;
+	u32 dram_type = sdram_params->base.dramtype;
+	void __iomem *pctl_base = dram->pctl;
+	struct tag_serial t_serial;
+	struct tag_ddr_mem t_ddrmem;
+	struct tag_soc_info t_socinfo;
+	u64 cs_cap[2];
+	u32 cs_pst = 0;
+	u32 split, split_size;
+	u64 reduce_cap = 0;
+
+	cs_cap[0] = sdram_get_cs_cap(cap_info, 0, dram_type);
+	cs_cap[1] = sdram_get_cs_cap(cap_info, 1, dram_type);
+
+	memset(&t_serial, 0, sizeof(struct tag_serial));
+
+	t_serial.version = 0;
+	t_serial.enable = 1;
+	t_serial.addr = CONFIG_DEBUG_UART_BASE;
+	t_serial.baudrate = CONFIG_BAUDRATE;
+	t_serial.m_mode = SERIAL_M_MODE_M0;
+	t_serial.id = 2;
+
+	atags_destroy();
+	atags_set_tag(ATAG_SERIAL,  &t_serial);
+
+	split = readl(&dram->ddrgrf->grf_ddrsplit_con);
+	memset(&t_ddrmem, 0, sizeof(struct tag_ddr_mem));
+	if (cap_info->row_3_4) {
+		cs_cap[0] =  cs_cap[0] * 3 / 4;
+		cs_cap[1] =  cs_cap[1] * 3 / 4;
+	} else if (!(split & (1 << SPLIT_BYPASS_OFFSET))) {
+		split_size = (split >> SPLIT_SIZE_OFFSET) & SPLIT_SIZE_MASK;
+		reduce_cap = (cs_cap[0] + cs_cap[1] - (split_size << 24)) / 2;
+	}
+	t_ddrmem.version = 0;
+	t_ddrmem.bank[0] = CFG_SYS_SDRAM_BASE;
+	if (cs_cap[1]) {
+		cs_pst = (readl(pctl_base + DDR_PCTL2_ADDRMAP0) & 0x1f) +
+			6 + 2;
+	}
+
+	if (cs_cap[1] && cs_pst > 27) {
+		t_ddrmem.count = 2;
+		t_ddrmem.bank[1] = 1 << cs_pst;
+		t_ddrmem.bank[2] = cs_cap[0];
+		t_ddrmem.bank[3] = cs_cap[1] - reduce_cap;
+	} else {
+		t_ddrmem.count = 1;
+		t_ddrmem.bank[1] = (u64)cs_cap[0] + (u64)cs_cap[1] - reduce_cap;
+	}
+
+	atags_set_tag(ATAG_DDR_MEM,  &t_ddrmem);
+
+	memset(&t_socinfo, 0, sizeof(struct tag_soc_info));
+	t_socinfo.version = 0;
+	t_socinfo.name = 0x1126;
+}
+
 static void print_ddr_info(struct rv1126_sdram_params *sdram_params)
 {
 	u32 split;
@@ -3482,6 +3553,7 @@ static int rv1126_dmc_init(struct udevice *dev)
 	ddr_set_rate_for_fsp(&dram_info, sdram_params);
 	copy_fsp_param_to_ddr();
 
+	ddr_set_atags(&dram_info, sdram_params);
 #if defined(CONFIG_CMD_DDR_TEST_TOOL)
 	save_rw_trn_result_to_ddr(&rw_trn_result);
 #endif
-- 
2.39.2

